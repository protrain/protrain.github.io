<!DOCTYPE html><html lang="de"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="https://protrain.github.io//favicon.ico"><meta name="google-site-verification" content="zy5uc-09F7GQWGXqdD2VxvB3CUI5CoP8X4RCbXZ3zHA"/><meta name="msvalidate.01" content="983653A7637B382C269F1718D19CF3DD"/><link rel="stylesheet" href="/assets/main.css"><link rel="canonical" href="https://protrain.github.io/blog/2018/11/19/buch-aufgaben-ohne-processing-howto.html"><link rel="alternate" type="application/rss+xml" title="Programmieren trainieren" href="/feed.xml"><title>Howto: Buch-Aufgaben ohne Processing lösen | Programmieren trainieren</title><meta name="generator" content="Jekyll v3.6.2"/><meta property="og:title" content="Howto: Buch-Aufgaben ohne Processing lösen"/><meta name="author" content="Stephan Wiefling, Luigi Lo Iacono"/><meta property="og:locale" content="de"/><meta name="description" content="Damit ihr so schnell wie möglich mit dem Programmiertraining loslegen könnt, sind alle Lösungsvorschläge im Buch für die Entwicklungsumgebung Processing optimiert. Processing lässt sich leicht installieren, erlaubt das ballastfreie und sofortige Loslegen, ohne mit Konfigurationswidrigkeiten hadern zu müssen, und beinhaltet Funktionen, mit denen einfache graphische Ausgaben programmiert werden können. Besonders das Zeichnen von Elementen kann in Processing durch die integrierten Funktionen deutlich schneller und leichter umgesetzt werden. Das bedeutet aber auch, dass einige unserer Lösungsvorschläge in der abgedruckten Form nicht in “reinem” Java oder Python funktionieren. Für fortgeschrittene Programmierer gibt es aber Wege, wie ihr unsere Aufgaben ohne Processing lösen könnt. Diese beschreiben wir in diesem Blogartikel."/><meta property="og:description" content="Damit ihr so schnell wie möglich mit dem Programmiertraining loslegen könnt, sind alle Lösungsvorschläge im Buch für die Entwicklungsumgebung Processing optimiert. Processing lässt sich leicht installieren, erlaubt das ballastfreie und sofortige Loslegen, ohne mit Konfigurationswidrigkeiten hadern zu müssen, und beinhaltet Funktionen, mit denen einfache graphische Ausgaben programmiert werden können. Besonders das Zeichnen von Elementen kann in Processing durch die integrierten Funktionen deutlich schneller und leichter umgesetzt werden. Das bedeutet aber auch, dass einige unserer Lösungsvorschläge in der abgedruckten Form nicht in “reinem” Java oder Python funktionieren. Für fortgeschrittene Programmierer gibt es aber Wege, wie ihr unsere Aufgaben ohne Processing lösen könnt. Diese beschreiben wir in diesem Blogartikel."/><link rel="canonical" href="https://protrain.github.io/blog/2018/11/19/buch-aufgaben-ohne-processing-howto.html"/><meta property="og:url" content="https://protrain.github.io/blog/2018/11/19/buch-aufgaben-ohne-processing-howto.html"/><meta property="og:site_name" content="Programmieren trainieren"/><meta property="og:image" content="https://protrain.github.io/images/og.jpg"/><meta property="og:type" content="article"/><meta property="article:published_time" content="2018-11-19T07:53:39+01:00"/> <script type="application/ld+json">
{"url":"https://protrain.github.io/blog/2018/11/19/buch-aufgaben-ohne-processing-howto.html","headline":"Howto: Buch-Aufgaben ohne Processing lösen","dateModified":"2018-11-19T07:53:39+01:00","datePublished":"2018-11-19T07:53:39+01:00","author":{"@type":"Person","name":"Stephan Wiefling, Luigi Lo Iacono"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://protrain.github.io/blog/2018/11/19/buch-aufgaben-ohne-processing-howto.html"},"description":"Damit ihr so schnell wie möglich mit dem Programmiertraining loslegen könnt, sind alle Lösungsvorschläge im Buch für die Entwicklungsumgebung Processing optimiert. Processing lässt sich leicht installieren, erlaubt das ballastfreie und sofortige Loslegen, ohne mit Konfigurationswidrigkeiten hadern zu müssen, und beinhaltet Funktionen, mit denen einfache graphische Ausgaben programmiert werden können. Besonders das Zeichnen von Elementen kann in Processing durch die integrierten Funktionen deutlich schneller und leichter umgesetzt werden. Das bedeutet aber auch, dass einige unserer Lösungsvorschläge in der abgedruckten Form nicht in “reinem” Java oder Python funktionieren. Für fortgeschrittene Programmierer gibt es aber Wege, wie ihr unsere Aufgaben ohne Processing lösen könnt. Diese beschreiben wir in diesem Blogartikel.","image":"https://protrain.github.io/images/og.jpg","@type":"BlogPosting","@context":"http://schema.org"}</script></head><body><header class="site-header" role="banner"><div class="wrapper"> <a class="site-title" href="/">Programmieren trainieren</a> <nav class="site-nav"> <input type="checkbox" id="nav-trigger" class="nav-trigger"/> <label for="nav-trigger"> <span class="menu-icon"> <svg viewBox="0 0 18 15" width="18px" height="15px"> <path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"/> <path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"/> <path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"/> </svg> </span> </label><div class="trigger"> <a class="page-link" href="/loesungen/loesungsvorschlaege-fuer-programmieraufgaben-auf-github.html">Lösungen</a> <a class="page-link" href="/buch-infos/programmieren-trainieren-java-python-lo-iacono-wiefling-schneider.html">Buch</a> <a class="page-link" href="/errata/fehler-korrekturen-und-verbesserungen.html">Errata</a></div> </nav></div> </header><main class="page-content" aria-label="Content"><div class="wrapper"> <article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header class="post-header"><h1 class="post-title" itemprop="name headline">Howto: Buch-Aufgaben ohne Processing lösen</h1><p class="post-meta"> <time datetime="2018-11-19T07:53:39+01:00" itemprop="datePublished"> 19.11.2018 </time> • <span itemprop="author" itemscope itemtype="http://schema.org/Person"><span itemprop="name">Stephan Wiefling, Luigi Lo Iacono</span></span></p> </header><div class="post-content" itemprop="articleBody"><p>Damit ihr so schnell wie möglich mit dem Programmiertraining loslegen könnt, sind <strong>alle Lösungsvorschläge im Buch für die Entwicklungsumgebung Processing optimiert</strong>. Processing lässt sich leicht installieren, erlaubt das ballastfreie und sofortige Loslegen, ohne mit Konfigurationswidrigkeiten hadern zu müssen, und beinhaltet Funktionen, mit denen einfache graphische Ausgaben programmiert werden können. Besonders das Zeichnen von Elementen kann in Processing durch die integrierten Funktionen deutlich schneller und leichter umgesetzt werden. Das bedeutet aber auch, dass einige unserer Lösungsvorschläge in der abgedruckten Form nicht in “reinem” Java oder Python funktionieren.</p><p>Für fortgeschrittene Programmierer gibt es aber Wege, wie ihr unsere Aufgaben ohne Processing lösen könnt. Diese beschreiben wir in diesem Blogartikel.</p><h2 id="java">Java</h2><p>Da Processing auf Java basiert, könnt ihr die Java-Library von Processing (Processing Core) in euer Projekt importieren. Die Macher von Processing haben hierfür <a href="https://processing.org/tutorials/eclipse/">eine ausführliche Anleitung geschrieben</a>.</p><h2 id="python">Python</h2><p>Für Python ist das nicht ganz so einfach anpassbar, da der Python-Mode in Processing vor der Ausführung den Python-Code in Java umwandelt (<a href="https://github.com/jdf/processing.py">Quelle</a>). Folglich existiert aktuell leider keine Möglichkeit, um die integrierten Processing-Funktionen in Python aufzurufen.</p><p>Abseits von Processing existieren für Python jedoch 2D-Zeichenlibraries (z.B. <a href="https://wiki.python.org/moin/TkInter">Tkinter</a>, <a href="https://www.pygame.org/">pygame</a> oder <a href="https://pypi.org/project/graphics.py/">graphics.py</a>). Diese kommen zwar unserer Meinung nach nicht an die Einfachheit von Processing heran, bieten jedoch ähnliche Funktionen. Wir zeigen anhand von Pygame, wie sich damit eine Zeichenaufgabe aus dem Buch in Standard Python 3 umsetzen lässt.</p><h3 id="beispiel-pygame">Beispiel: pygame</h3><p>Die Pygame-Programmbibliothek bietet im Gegensatz zu Tkinter auch 2D-Rotationen, weshalb wir sie zur Umsetzung der <a href="https://github.com/protrain/loesungen/blob/master/loesungen_in_python/04-kontrollstrukturen/aufgabe_W_4_08_windrad/aufgabe_W_4_08_windrad.pyde">Windrad-Aufgabe</a> aus dem Kapitel “Kontrollstrukturen” nutzen können. Hierbei werden auch die Grenzen und Möglichkeiten von pygame deutlich.</p><h4 id="installation">Installation</h4><p>Installieren können wir pygame in der Kommandozeile über den Python-Paketmanager <strong>pip</strong>:</p><div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pip install pygame
</code></pre></div></div><p>Alle Klassen und Funktionen von pygame sind in der <a href="https://www.pygame.org/docs/">offiziellen Dokumentation</a> beschrieben. Darüber hinaus sind <a href="https://www.pygame.org/wiki/tutorials">auf der offiziellen Website einige Tutorials</a> zu finden.</p><h4 id="los-gehts">Los geht’s</h4><p>Die Initialisierung von pygame ist relativ simpel:</p><div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># coding=utf-8</span>
<span class="kn">import</span> <span class="nn">sys</span><span class="p">,</span> <span class="n">pygame</span>

<span class="c"># Starte Pygame</span>
<span class="n">pygame</span><span class="o">.</span><span class="n">init</span><span class="p">()</span>
</code></pre></div></div><p>Die Fenstergröße (in Processing wäre das der <code class="highlighter-rouge">size()</code>-Befehl) setzen wir mit:</p><div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># Definiere Fenstergröße</span>
<span class="n">width</span> <span class="o">=</span> <span class="mi">800</span>
<span class="n">height</span> <span class="o">=</span> <span class="mi">800</span>

<span class="c"># Setze Abmaße für Bildschirmfenster</span>
<span class="n">screen</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">display</span><span class="o">.</span><span class="n">set_mode</span><span class="p">((</span><span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">))</span>
</code></pre></div></div><p>Mit dem hier initialisierten <code class="highlighter-rouge">screen</code>-Objekt können wir später den Inhalt des Bildschirmfensters setzen.</p><p>Die <code class="highlighter-rouge">draw()</code>-Funktion in Processing können wir in Form einer Endlosschleife abbilden:</p><div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">while</span> <span class="mi">1</span><span class="p">:</span>
  <span class="c"># Hier folgen dann die weiteren Befehle</span>
</code></pre></div></div><p>Innerhalb dieser Schleife können wir dann die Fensterinhalte zeichnen. Zunächst definieren wir den Hintergrund des Bildschirmfensters:</p><div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">white</span> <span class="o">=</span> <span class="mi">255</span><span class="p">,</span> <span class="mi">255</span><span class="p">,</span> <span class="mi">255</span>

<span class="c"># Setze Hintergrund auf Weiß</span>
<span class="n">screen</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="n">white</span><span class="p">)</span>
</code></pre></div></div><h4 id="probleme">Probleme</h4><p>Da wir <strong>in pygame keinen Bogen mit Farbfüllung zeichnen können</strong>, verwenden wir im Beispiel stattdessen ein Rechteck.</p><p>Pygame besitzt von sich aus leider keine Funktion zum Verschieben des Koordinatensystems (<code class="highlighter-rouge">translate()</code>-Funktion in Processing). Folglich müssen wir hier selbst die Koordinaten der einzelnen Elemente berechnen. Dies hat auch zur Folge, dass wir das Koordinatensystem nicht drehen können (<code class="highlighter-rouge">rotate()</code>-Befehl in Processing).</p><p>Daher sind Rotationen in pygame nicht so trivial wie in Processing umzusetzen. Nach Beginn der Schleife wie in der Processing-Lösung</p><div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># Erzeuge Einzelteile des Windrades</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">8</span><span class="p">):</span>
</code></pre></div></div><p>sind folgende Schritte notwendig:</p><p><span>1.</span> Wir müssen zunächst eine Zeichenfläche (leeres Bild) erzeugen</p><div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># Erzeuge neue Zeichenfläche für Windrad-Element (radius x radius)</span>
<span class="n">surface</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">Surface</span><span class="p">(((</span><span class="n">radius</span><span class="p">,</span> <span class="n">hoehe</span><span class="p">)))</span>
</code></pre></div></div><p><span>2.</span> dort entsprechend draufzeichnen</p><div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># Setze Hintergrund der Zeichenfläche auf Transparent (blende weiße Farbe aus)</span>
<span class="n">surface</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="n">white</span><span class="p">)</span>
<span class="n">surface</span><span class="o">.</span><span class="n">set_colorkey</span><span class="p">(</span><span class="n">white</span><span class="p">)</span>

<span class="c"># Male Rechteck auf die Zeichenfläche</span>
<span class="n">pygame</span><span class="o">.</span><span class="n">draw</span><span class="o">.</span><span class="n">rect</span><span class="p">(</span><span class="n">surface</span><span class="p">,</span> <span class="n">windrad_farbe</span><span class="p">,</span> <span class="n">windrad_abmasse</span><span class="p">)</span>
</code></pre></div></div><p><span>3.</span> diese Zeichenfläche dann rotieren</p><div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># Rotiere den Bogen um entsprechende Gradzahl</span>
<span class="n">winkel</span> <span class="o">=</span> <span class="o">-</span><span class="mi">45</span><span class="o">*</span><span class="n">i</span>

<span class="c"># Einfache Rotation durchführen</span>
<span class="c"># Achtung: Ab 90 Grad Rotation verändert pygame die Abmaße unserer</span>
<span class="c"># Zeichenfläche</span>
<span class="n">surface</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">transform</span><span class="o">.</span><span class="n">rotate</span><span class="p">(</span><span class="n">surface</span><span class="p">,</span> <span class="n">winkel</span><span class="p">)</span>
</code></pre></div></div><p><span>4.</span> und diese Zeichenfläche an die entsprechende Position im Fenster zeichnen.</p><div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># Rotiere den Bogen um entsprechende Gradzahl</span>
<span class="n">winkel</span> <span class="o">=</span> <span class="o">-</span><span class="mi">45</span><span class="o">*</span><span class="n">i</span>

<span class="c"># Einfache Rotation durchführen</span>
<span class="c"># Achtung: Ab 90 Grad Rotation verändert pygame die Abmaße unserer</span>
<span class="c"># Zeichenfläche</span>
<span class="n">surface</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">transform</span><span class="o">.</span><span class="n">rotate</span><span class="p">(</span><span class="n">surface</span><span class="p">,</span> <span class="n">winkel</span><span class="p">)</span>
</code></pre></div></div><p><span>5.</span> Ab einer Rotation um 90 Grad werden von pygame die Bildmaße der Zeichenfläche verändert, sodass wir hier Sonderfälle behandeln müssen.</p><div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># Berechne Position der gedrehten Zeichenfläche.</span>
<span class="k">if</span> <span class="n">i</span><span class="o">&lt;</span><span class="mi">3</span><span class="p">:</span>
    <span class="c"># Zeichne unten rechts</span>
    <span class="c"># (obere linke Ecke der Zeichenfläche in der Mitte des Bildes)</span>
    <span class="n">position</span> <span class="o">=</span> <span class="n">surface</span><span class="o">.</span><span class="n">get_rect</span><span class="p">(</span><span class="n">topleft</span> <span class="o">=</span> <span class="n">mitte</span><span class="p">)</span>
<span class="k">elif</span> <span class="n">i</span><span class="o">&lt;</span><span class="mi">5</span><span class="p">:</span>
    <span class="c"># Zeichne unten links</span>
    <span class="c"># (obere rechte Ecke der Zeichenfläche in der Mitte des Bildes)</span>
    <span class="n">position</span> <span class="o">=</span> <span class="n">surface</span><span class="o">.</span><span class="n">get_rect</span><span class="p">(</span><span class="n">topright</span> <span class="o">=</span> <span class="n">mitte</span><span class="p">)</span>
<span class="k">elif</span> <span class="n">i</span><span class="o">&lt;</span><span class="mi">7</span><span class="p">:</span>
    <span class="c"># Zeichne oben links</span>
    <span class="c"># (untere rechte Ecke der Zeichenfläche in der Mitte des Bildes)</span>
    <span class="c"># Wir müssen dabei die Y-Position um die Hälfte der Höhe verschieben, damit</span>
    <span class="c"># wir in der Mitte des Windradflügels sind</span>
    <span class="n">position</span> <span class="o">=</span> <span class="n">surface</span><span class="o">.</span><span class="n">get_rect</span><span class="p">(</span><span class="n">bottomright</span> <span class="o">=</span> <span class="p">(</span><span class="n">mitte</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">mitte</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="n">hoehe</span><span class="o">/</span><span class="mi">2</span><span class="p">))</span>
<span class="k">else</span><span class="p">:</span>
    <span class="c"># Zeichne oben rechts</span>
    <span class="c"># (untere linke Ecke der Zeichenfläche in der Mitte des Bildes)</span>
    <span class="c"># Wir müssen dabei die Y-Position um die Hälfte der Höhe verschieben, damit</span>
    <span class="c"># wir in der Mitte des Windradflügels sind</span>
    <span class="n">position</span> <span class="o">=</span> <span class="n">surface</span><span class="o">.</span><span class="n">get_rect</span><span class="p">(</span><span class="n">bottomleft</span> <span class="o">=</span> <span class="p">(</span><span class="n">mitte</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">mitte</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="n">hoehe</span><span class="o">/</span><span class="mi">2</span><span class="p">))</span>
</code></pre></div></div><p><span>6.</span> Schließlich zeichnen wir diese rotierte Zeichenfläche in das Bildschirmfenster:</p><div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># Zeichne Fläche in das Bildschirmfenster</span>
<span class="n">screen</span><span class="o">.</span><span class="n">blit</span><span class="p">(</span><span class="n">surface</span><span class="p">,</span> <span class="n">position</span><span class="p">)</span>
</code></pre></div></div><p>Nach Ende dieser Schleife müssen wir dann noch dafür sorgen, dass die gezeichneten Elemente im Fenster dargestellt werden. Dies erfolgt mit:</p><div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># Zeige alle gezeichneten Elemente im Fenster an</span>
<span class="n">pygame</span><span class="o">.</span><span class="n">display</span><span class="o">.</span><span class="n">flip</span><span class="p">()</span>
</code></pre></div></div><p>Womit wir folgendes Ergebnis erhalten:</p><p><img src="/images/windrad_pygame.png" alt="Das 'Windrad' in Pygame"/></p><p><a href="https://github.com/protrain/loesungen/blob/master/blogserie-loesungen/windrad-ohne-processing/windrad.py">Die Lösung haben wir für euch auch auf Github hochgeladen</a>.</p><h2 id="fazit">Fazit</h2><p>Die Lösungen lassen sich auch ohne Processing umsetzen. Allerdings wird sich dann besonders in Python der Schwierigkeitsgrad deutlich erhöhen. Aufgaben mit Rotationen sind damit deutlich schwieriger umzusetzen (Tkinter hat keine integrierte Rotationsfunktion!).</p><p>Wenn ihr allerdings schon die Workouts aus dem Buch in Processing geschafft habt, könnt ihr es natürlich auch mal in “reinem” Java oder Python probieren. Wenn ihr Lösungen ohne Processing umgesetzt habt, stellen wir sie gerne im <a href="https://github.com/protrain/loesungen">Github-Repository</a> zum Buch online.</p></div> </article></div> </main><footer class="site-footer"><div class="wrapper"><h2 class="footer-heading">Programmieren trainieren</h2><div class="footer-col-wrapper"><div class="footer-col footer-col-1"><ul class="contact-list"><li> Luigi Lo Iacono, Stephan Wiefling, Michael Schneider</li></ul></div><div class="footer-col footer-col-2"><ul class="social-media-list"><li> <a href="https://github.com/protrain"><span class="icon icon--github"><svg viewBox="0 0 16 16" width="16px" height="16px"><path fill="#828282" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/></svg> </span><span class="username">protrain</span></a></li></ul></div><div class="footer-col footer-col-3"><p>Die Website zum Buch. Mit über 120 Workouts in Java und Python.</p></div></div></div></footer></body></html>